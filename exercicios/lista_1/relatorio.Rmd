---
title: "Primeira Lista de Exercícios de Arquiteturas/PAD"
author: "Felipe Menino Carlos"
date: "28/04/2020"
output: pdf_document
bibliography: ref.bib
---

```{r, echo=FALSE}
library(reticulate)
reticulate::use_condaenv('/home/felipe/anaconda3/')
```

```{python, echo=FALSE}
import numpy as np
import pandas as pd
from plotnine import *

import plotnine

plotnine.options.figure_size = (5.4, 3.8)

import warnings
warnings.filterwarnings("ignore")
```

## Objetivo

O principal objetivo desta lista de exercícios é reforçar a fixação dos conceitos vistos em sala de aula sobre pipeline, sobre a lei de Amdahl e sobre o speedup resultante da execução de um programa num sistema paralelo. Para os exercícios nos quais são pedidos gráficos, utilize qualquer programa de plotagem.\

## Exercícios

Abaixo são apresentados os exercícios propostos na lista, estes foram resolvidos utilizando a linguagem de programação [Python](https://www.python.org/) junto a biblioteca de funcionalidades para a visualização gráfica [plotnine](https://plotnine.readthedocs.io/en/stable/)\

1) Considere uma tarefa que pode ser dividida em sub-tarefas com durações de 15, 25, 30 e 20 segundos, respectivamente. Cada sub-tarefa é executada por um módulo especializado, e a execução é feita em modo pipeline.

- (a) Qual é o tempo de ciclo mínimo para o pipeline ?

> O pipeline trabalha utilizando um ciclo de *clock* único, de modo que o tamanho deste ciclo seja capaz de suportar a operação mais lenta [@patterson2014organizacao], desta forma, o tempo de ciclo mínimo para este caso será $30s$.

- (b) Supondo que existam 100 tarefas a executar, qual o speedup em relação à execução num modo estritamente serial ?

> Primeiro determinamos o valor em relação a execução sem pipeline.

$$
SemPipeline = N * K = 100 * (15 + 25 + 30 + 20) = 9000
$$

> Agora, façamos a consideração do modo de execução com Pipeline


$$
ComPipeline = K + (N - 1) = 4 + (100 - 1) = 103
$$

> Nesta parte, é considerado que a conta $SemPipeline$ está sendo `quantificada` em segundos e que o $ComPipeline$ apenas possui ciclos, desta forma, para tornar comparável, faz-se a multiplicação do $ComPipeline$ por 30s, já que este representa o tempo de cíclo único utilizado no Pipeline.

$$
ComPipeline_S = ComPipeline * 30 = 3090
$$

> Por fim, o Speedup pode ser calculado

$$
Speedup = \frac{N * K}{K + (N - 1)} = \frac{SemPipeline}{ComPipeline_S} = \frac{9000}{3090} = 2.912621
$$


> Com isto, é possível afirmar que o Speedup entre um modo pipeline e um estritamente serial é $2.912621$.


- (c) Caso seja possível subdividir uma das sub-tarefas em duas novas sub-tarefas de igual duração, associando um módulo  para a execução de cada uma, qual das sub-tarefas deve ser escolhida para divisão ?

> Para reduzir a necessidade de um ciclo muito grande, a sub-tarefa escolhida para a subdivisão pode ser a que possui o tempo de execução igual a $30s$

- (d) Após a divisão proposta no ítem anterior, qual o novo speedup possível em relação à execução estritamente serial das 100 tarefas ?

> Inicialmente é necessário definir qual será o novo tamanho do ciclo, uma vez que o maior ciclo que antes era $30s$ deixou de existir, assim, o novo tamanho de ciclo para o pipeline passa a ser $25s$, por possuir o maior tempo de execução. Com esta mudança, os mesmos passos apresentados no exercício 1(b) podem ser realizados. O valor $SemPipeline$ permanece o mesmo, já que mesmo dividindo as atividades, o valor total, utilizado na conta, será o mesmo.

$$
ComPipeline = K + (N - 1) = 5 + (100 - 1) = 104
$$

> Agora o calculo de tempo é aplicado, considerando o valor $25s$

$$
ComPipeline_S = ComPipeline * 25 = 2600
$$

> Calculando o Speedup tem-se que

$$
Speedup = \frac{N * K}{K + (N - 1)} = \frac{SemPipeline}{ComPipeline_S} = \frac{9000}{2600} = 3.461538
$$

> Com isto, com a mudança no tamanho das subtarefas, tem-se um Speedup de $3.461538$ com relação ao modo estritamente serial.\

2) Considere  a  expressão  para  o  speedup vista  em  aula, $S_P = \frac{1}{1 - f + \frac{f}{P}}$.  Plote  o  speedup como  função  do  número  de  processadores  (P),  dentro  do  intervalo    $1 \leq P \leq 128$, supondo que a fração paralelizável (f) de um programa corresponde a:

<!-- Para a realização do exercício, inicialmente faz-se a definição da função de Amdahl proposta do exercício em Python. A implementação é apresentada abaixo.\ -->

```{python, echo = FALSE}
def speedup_amdahl(f, p, unique = False):
    if unique:
        p = np.array([p])
    
    return pd.DataFrame({
        'f': f,
        'p': p,
        'speedup': 1 / (1 - f + (f / p))
    })
```

* (a) 98%

```{python, echo = FALSE, fig.align="center"}
plotnine.options.figure_size = (5.4, 3.5)

quantidade_de_processadores = np.arange(1, 129)
questao_a = speedup_amdahl(0.98, quantidade_de_processadores)

(ggplot(questao_a, aes(x = 'p', y = 'speedup'))
    + geom_line(size = 0.3)
    + ylim(0, 40)
    + xlab('Quantidade de processadores') + ylab('Speedup')
    + scale_x_continuous(breaks = np.arange(0, 128, 10))
    + ggtitle('Speedup com $p \in [1, 128]$ e f = 98%'))
```

> Ao considerar a plotagem realizada, é possível perceber a influência da quantidade de processadores no Speedup quando a fração de paralelização do programa analisado é alto, neste, quanto maior a quantidade de processadores, maior o Speedup. 

> É importante lembrar que, mesmo com o aumento apresentado ser crescente, há um limite para tal crescimento.

* (b) 80%

```{python, echo = FALSE, fig.align = "center"}
questao_b = speedup_amdahl(0.80, quantidade_de_processadores)

(ggplot(questao_b, aes(x = 'p', y = 'speedup'))
    + geom_line(size = 0.3)
    + ylim(0, 40) + xlim(0, 128)
    + xlab('Quantidade de processadores') + ylab('Speedup')
    + scale_x_continuous(breaks = np.arange(0, 128, 10))
    + ggtitle('Speedup com $p \in [1, 128]$ e f = 80%'))
```

> O resultado desta segunda plotagem ajuda na afirmação feita anteriormente, onde a quantidade de processadores influência positivamente somente quando o programa favorece, ou seja, quando o programa possuí uma boa fração paralelizável.

> A função paralelizável pode até ser considerada alta, com 80\%, porém, este ainda é um valor baixo para melhor consumir os recursos, o que faz o desempenho não ser muito bom, mesmo com o aumento da quantidade de processadores.\

3) Plote  agora  o  speedup  em  função  da  fração  paralelizável (f)  de  um  programa,  para  o intervalo  $0 < f < 1$, supondo um sistema com:

- (a) 8 processadores
- (b) 128 processadores

> Este exercício apresenta um outro ponto de vista do que foi apresentado no exercício anterior. Faz isto através da variação do fator de paralelização (f), de modo que a influência da influência da fração paralelizável $f$ de um programa seja visulizada.

* (a) 8 processadores

```{python, echo = FALSE, fig.align = "center"}
intervalo_fracao_paralelizavel = np.arange(0.1, 1, 0.1)

questao_a = speedup_amdahl(intervalo_fracao_paralelizavel, 8)

(ggplot(questao_a, aes(x = 'f', y = 'speedup'))
    + geom_line(size = 0.3)
    + xlab('Fração paralelizável (%)') + ylab('Speedup')
    + ylim(0, 10)
    + scale_x_continuous(breaks = questao_a['f'])
    + ggtitle('Speedup com $f \in (0, 1)$ e p = 8'))
```

\newpage

* (b) 128 processadores

```{python, echo = FALSE, fig.align = "center"}
questao_b = speedup_amdahl(intervalo_fracao_paralelizavel, 128)

(ggplot(questao_b, aes(x = 'f', y = 'speedup'))
    + geom_line(size = 0.3)
    + xlab('Fração paralelizável (%)') + ylab('Speedup')
    + ylim(0, 10)
    + scale_x_continuous(breaks = questao_b['f'])
    + ggtitle('Speedup com $f \in (0, 1)$ e p = 128'))
```

> Ao analisar as figuras é possível perceber a influência da fração paralelizável do programa. Ao comparar os gráficos, até certo ponto, os dois sistemas, mesmo possuindo uma quantidade muito diferente de processadores, acabam tendo resultados próximos, mesmo havendo diferenças significativas na quantidade de recursos de cada um dos sistemas analisados. Assim, é possível perceber que, como apresentado em sala de aula, se o programa não consumir todos os recursos computacionais de modo a tirar o máximo proveito do mesmo, tem-se disperdício de recursos, financeiros e computacionais.\

4) Considere um programa no qual a fração paralelizável corresponde a  90%  do tempo de uma execução convencional em um processador. 


```{python, echo = FALSE}
def eficiencia_paralela(speedup, p):
    return speedup / p
    
# questao_a = speedup_amdahl(.90, 16, True)
# print(f"Speedup com p = 16 = {questao_a['speedup'].iloc[0]}")
```

* (a) Calcule o speedup que seria obtido num sistema com 16 processadores.

$$
S_P = \frac{1}{1 - f + \frac{f}{P}} = \frac{1}{1 - 0.9 + \frac{0.9}{16}} =  6.4
$$

* (b) Calcule o speedup que seria obtido num sistema com 64 processadores.


$$
S_P = \frac{1}{1 - f + \frac{f}{P}} = \frac{1}{1 - 0.9 + \frac{0.9}{64}} = 8.767123
$$

* (c) Quantas vezes o sistema com 64 processadores é mais rápido que o sistema com 16 processadores para este programa?

> Esta relação pode ser determinada como a equação apresentada abaixo

$$
\frac{8.767123}{6.4} = 1.369863
$$

\newpage

* (d) Quantos  processadores  são  necessários  para  executar  este  programa  na  metade do tempo da execução no sistema com 16 processadores? (Justifique a resposta)

> Para este exercício, antes de realizar testes aplicando a lei de Amdahl para verificar a quantidade de processadores necessários, o que computacionalmente poderia ser realizado de forma simples, façamos a análise do `Speedup máximo` que este programa pode alcançar.

$$
\frac{1}{1 - f} = \frac{1}{1 - 0.90} \approx 10
$$

> Ao verificar que o speedup máximo, para este contexto, é aproximadamente 10, fica claro que não é possível melhorar a execução a ponto de diminuir sua execução pela metadade do que foi alcançado com 16 processadores. Para confirmar tal questão, a visualização abaixo apresenta uma extrapolação dos valores de $P$ considerando sua variação em um intervalo $0 \le P \le 5000$

```{python, echo = FALSE, fig.align = "center"}
speedup_de_teste = speedup_amdahl(.90, np.arange(0, 5000, 1))
(ggplot(speedup_de_teste, aes(x = 'p', y = 'speedup')) + geom_line(size = 0.5)
    + xlab('Quantidade de processadores') + ylab('Speedup')
    + ggtitle('Limite de Speedup'))
```

\newpage

5) Utilizando  as  mesmas  escalas  dos  gráficos  construídos  acima  em `2-a` e em  `3-a`, respectivamente, plote o `speedup-em-escala` para os seguintes casos:

```{python, echo=FALSE}
def speedup_gustafson(f, p):
    return pd.DataFrame({
        'f': f,
        'p': p,
        'speedup': (p-1) * f + 1
    })
```

<!--ToDo-->
- (a) $f = 98\% ,  1 \le P \le 128$\


```{python, echo = FALSE, fig.align = "center"}
questao_a = speedup_gustafson(0.98, np.arange(1, 129))

(ggplot(questao_a, aes(x = 'p', y = 'speedup'))
    + geom_line(size = 0.3)
    + ylim(0, 41) # + xlim(0, 128)
    + xlab('Quantidade de processadores') + ylab('Speedup')
    + scale_x_continuous(breaks = np.arange(0, 128, 10))
    + ggtitle('Speedup com $p \in [1, 128]$ e f = 98%'))
```

<!--ToDo descrição-->
Comparando com o gráfico do exercício 2a, que possuí os mesmos valores,  é possível perceber que ao realizar a consideração do speedup em escala, tem-se um ganho que cresce muito mais rápido que o speedup de Amdahl. Isto ocorre por conta do ponto de vista que está sendo considerado neste calculo, onde problemas maiores serão aplicados no sistema em questão.

\newpage

* (b) 8 processadores,  $0 < f < 1$\

```{python, echo = FALSE, fig.align = "center"}
questao_b = speedup_gustafson(np.arange(0.1, 1, 0.1), 8)

(ggplot(questao_b, aes(x = 'f', y = 'speedup'))
    + geom_line(size = 0.3)
    + xlab('Fração paralelizável (%)') + ylab('Speedup')
    + ylim(0, 10)
    + scale_x_continuous(breaks = questao_b['f'])
    # + scale_y_continuous(breaks = np.arange(0, questao_b['speedup'].max(), 2.5))
    + ggtitle('Speedup com $f \in (0, 1)$ e p = 8'))
```
 
\newpage
# Referências
